# 并发编程

### 一. 基本概念

1. 进程 VS 线程
   1. 进程：**进程是操作系统进行资源分配的最小单位。**  多个进程之间互相独立。
   2. 线程：**线程是CPU进行调度的最小单位。**线程必须依赖于进程存在。一个进程中的所有线程共享该进程的资源(包括CPU、内存空间、磁盘IO等)。
2. 超线程技术：可以使核心数与线程数形成1:2的关系。
3. CPU时间片轮转机制(RR调度)
4. 并行 VS 并发

### 二. 并发编程的优缺点

1. 优点
   1. 提高CPU利用率
   2. 提高响应时间
   3. 异步化 
2. 缺点
   1. 加大开发难度
   2. 引入上下文切换
   3. 可能带来各种问题(线程安全问题、死锁、饥饿等)

### 三. 线程的基本操作

1. 启动与终止
   1. 不要使用stop()、suspend()、resume()等已被废弃的方法。已stop()为例，它会强制终止线程，可能导致有些资源未被正确释放。
2. 线程中断
   1. 通过interrupt()方法，将线程中断标志位置位，线程会响应中断
3. 线程的按顺序执行：join()方法
4. 线程优先级
5. 守护线程

### 四. 锁

1. synchronized：对象锁
2. volatile：保证可见性、有序性。**适用于一写多读的场景。**
3. ThreadLocal：Spring在事务管理中使用ThreadLocal，**实现当前线程与数据库连接的绑定**。
   1. 引申：WeakReference
   2. 引申：ThreadLocal的内存泄漏问题
   3. 引申：ThreadLocal的线程不安全问题

### 五. 线程间的协作

1. wait/notify

2. 等待/通知标准范式

3. ```java
   //等待线程
   synchronized(lock){
     while (条件不满足){
       lock.wait();	//线程在阻塞前会释放持有的锁。被唤醒后,线程需要重新竞争锁,竞争到锁后,才能执行后续逻辑
     }
     //执行业务逻辑
   }
   
   //通知线程
   synchronized(lock){
     //条件满足,唤醒等待的线程。notifyAll()并不会释放锁
     lock.notifyAll();
   }
   
   ```

### 六. 常用并发工具

1. Fork/Join框架
2. CountdownLatch
3. CyclicBarrier
4. Semaphore

### 七. 原子操作CAS

1. 思想：乐观锁
2. 底层基于现代处理器的CAS(Compare And Set)指令，保证操作的原子性
3. 问题：
   1. ABA问题
   2. 开销问题
   3. 只能保证单个变量的原子性操作，如果想同时控制多个变量，则需要加锁处理，或者将多个需要修改的变量封装成一个类，使用AtomicReference。

### 八. 显式锁 

1. 锁的可重入
2. 公平锁 VS 非公平锁：**ReentrantLock默认使用非公平锁，比公平锁有更高的吞吐率(效率更高)，但是有可能造成线程饥饿。**
3. **读写锁——读写分离，在读多写少的场景下可大幅度提升性能**

### 九. AQS

1. 模板方法模式
2. 使用 int state 表示当前同步器状态
3. 使用同步队列(双向列表)维护所有等待锁的线程
4. 使用等待队列维护等待Condition的线程

### 十. 并发容器

1. hash算法、摘要算法(MD5、SHA-1)——是一种压缩映射



