# MySQL

![](MySQL.jpg)

### 一. MySQL整体架构

![](MySQL架构.png)

1. Server层

   涵盖MySQL大多数的核心服务，以及所有的内置函数。所有跨存储引擎的功能都在这一层实现，如存储过程、触发器、视图等。

   1. 连接器

      负责与客户端建立连接、获取权限、维持和管理连接。

      **每个连接的权限判断逻辑，都依赖于连接刚建立好之后所读取到的权限，这就意味着，一个用户一旦成功建立连接后，即使用管理员账户对这个用户权限进行了修改，也不会影响到已经存在的连接的权限。修改完成后，只有重新建立的连接才会使用新的权限。**

   2. 查询缓存

      以key-value的形式，在内存中缓存{查询语句:查询结果}。如果缓存命中，则直接将结果返回给客户端，不再执行后续的操作。

      **查询缓存往往弊大于利。因为一旦对一个表进行了更新操作，该表对应的所有查询缓存都要清空，这样对于更新操作较多的表来说，缓存命中率就会很低。**

      **需要注意的是，MySQL 8.0 版本直接将查询缓存的整块功能删掉了，也就是说8.0开始彻底没有这个功能了。**

   3. 分析器

      主要是对SQL语句进行词法解析和语法解析。

   4. 优化器

      **主要是当表存在多个索引时，决定使用哪个索引。**或者是在一个语句有多表关联时(join)，决定各个表的连接顺序。

   5. 执行器

      执行SQL语句。在执行前，首先判断是否有对该表的权限，如果没有，则返回没有权限的异常。

      **如果有权限，就会调用引擎提供的接口，执行数据的查询或修改。**

      数据库的慢查询日志中有一个 rows_examine字段，表示这个语句执行过程中扫描了多少行，这个值就是在执行器每次调用引擎的接口扫描数据时累加的。有时执行器调用了一次，引擎内部却扫描了多行，**因此引擎扫描行数和rows_examine字段并不是完全相同的。**

2. 引擎层

   负责实际数据的存储和提取。其架构是插件模式的，支持InnoDB、MyISAM、Memory等多种引擎。从MySQL5.5.5之后，InnoDB成为默认的存储引擎。

### 二. 更新语句的执行流程

1. redo log

   **redo log通常是物理日志，记录的是数据页的物理修改，而不是某一行或某几行修改成怎样怎样。通常它用来恢复提交后的物理数据页(恢复数据页，且只能恢复到最后一次提交的位置)。**

   当有一条记录需要更新的时候，InnoDB引擎就会将记录写到redo log里，并同步更新到缓存，这时更新操作就算完成了。同时，InnoDB引擎会在适当的时候将这个操作的记录更新到磁盘中，这个操作往往是在系统比较空闲的时候做的。**这也就是MySQL中常说的WAL(Write-Ahead Logging)技术，即先写日志，再写磁盘。**

   有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前已经提交的记录也不会丢失，这个能力成为crash-safe。

   InnoDB 的redo log日志大小是固定的，比如可以配置一组4个文件，每个文件大小为1G，一共4G的文件。日志文件从头开始写，写到末尾就回到头部循环写。其结构如下图：

   ![](/Users/yufeifei/Desktop/架构/MySQL/InnoDB.png)

   write pos是当前要写入的位置，一边写一遍循环后移。checkpoint是当前要擦除的位置，也是循环后移的，擦除记录前要将记录更新到数据文件。

   write pos和checkpoint之间的位置是可以写入数据的位置。如果write pos追上了checkpoint，表示当前redo log已满，需要执行一次擦除操作，并把checkpoint向前推进。

2. bin log

   **bin log：以事件的形式记录了所有对数据的修改操作，但是不包括查询操作。**

   bin log VS redo log

   |      | redo log                                   | bin log                                                      |
   | ---- | ------------------------------------------ | ------------------------------------------------------------ |
   |      | InnoDB引擎所特有                           | Server层实现的，所有引擎都可以使用                           |
   |      | 物理日志，记录"在某个数据页上做了什么修改" | 逻辑日志，记录这个语句的原始逻辑，如"把 ID=2的行的c字段加1"  |
   |      | 循环写，空间固定，可能会用完               | 追加写，binlog文件写到一定大小之后会切换到下一个，并不会覆盖以前的日志 |

3. 两阶段提交

   redo log和bin log都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保存逻辑上的一致。

   具体流程为：

   1. 执行器调用引擎接口，修改数据
   2. 引擎将新数据写入内存
   3. 将修改写入redo log，并将redo log设为prepare状态
   4. 引擎返回给执行器修改成功
   5. Server层写入bin log
   6. 提交事务，引擎将redo log设为commit状态

### 三. 事务隔离级别

1. 事务：一组数据库操作，要么全部成功，要么全部失败。

2. **MySQL的事务是在引擎层实现的，有些引擎是不支持事务的。MySQL默认的InnoDB引擎可以支持事务。**

3. 实现原理：

   1. 数据库中有一个**视图**的概念，数据库会创建一个视图，访问的时候都以视图的逻辑结果为准。
   2. 在repeatable-read级别下，视图是在开启事务时创建的，且整个事务存在期间都使用这个视图，因此可以保证同一个事务内每次读取到的数据都是一致的，不受其他事务影响。
   3. 在read-committed级别下，视图是在每个SQL语句开始执行的时候创建的，因此会读取到其他事务已经提交的记录。
   4. read-uncommitted级别没有视图的概念，每次都是读取记录上的最新值。
   5. serializable级别直接采用加锁的方式避免了并发访问，也不会用到视图。

4. **MVCC：多版本并发控制——同一条记录在系统中可以存在多个版本，不同时刻开启的事务，在读取这条记录时会使用不同的视图。**

   在MySQL中，每条记录在更新的时候，都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。当没有事务需要用到这些回滚日志时，回滚日志就会删除。

5. **尽量不要使用长事务**

   1. 长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。
   2. 除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个数据库。
   3. 建议你总是使用 set autocommit=1, 通过显式语句的方式来启动事务。

   